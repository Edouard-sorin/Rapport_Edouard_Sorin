<!DOCTYPE html>
<html lang="fr-FR" xml:lang="fr-FR">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Méthodologie | Rapport de stage Edouard Sorin</title>
  <meta name="description" content="Modèle de livre écrit avec bookdown." />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Méthodologie | Rapport de stage Edouard Sorin" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Modèle de livre écrit avec bookdown." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Méthodologie | Rapport de stage Edouard Sorin" />
  
  <meta name="twitter:description" content="Modèle de livre écrit avec bookdown." />
  



<meta name="date" content="2021-04-07" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="problématique.html"/>
<link rel="next" href="references.html"/>
<style type="text/css">
p.abstract{
  text-align: center;
  font-weight: bold;
}
div.abstract{
  margin: auto;
  width: 90%;
}
</style>
<script src="libs/header-attrs-2.7/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Ouvrage Edouard</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Remerciement</a></li>
<li class="chapter" data-level="" data-path="gloassaire.html"><a href="gloassaire.html"><i class="fa fa-check"></i>Gloassaire</a>
<ul>
<li class="chapter" data-level="0.1" data-path="gloassaire.html"><a href="gloassaire.html#contexte-général"><i class="fa fa-check"></i><b>0.1</b> Contexte général</a></li>
<li class="chapter" data-level="0.2" data-path="gloassaire.html"><a href="gloassaire.html#etat-des-connaissances-sur-la-maladie"><i class="fa fa-check"></i><b>0.2</b> Etat des connaissances sur la maladie</a></li>
<li class="chapter" data-level="0.3" data-path="gloassaire.html"><a href="gloassaire.html#la-réémergence-du-hlb-à-la-réunion"><i class="fa fa-check"></i><b>0.3</b> La réémergence du HLB à la Réunion</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="problématique.html"><a href="problématique.html"><i class="fa fa-check"></i><b>1</b> Problématique</a></li>
<li class="chapter" data-level="2" data-path="méthodologie.html"><a href="méthodologie.html"><i class="fa fa-check"></i><b>2</b> Méthodologie</a>
<ul>
<li class="chapter" data-level="2.1" data-path="méthodologie.html"><a href="méthodologie.html#echantillonnage"><i class="fa fa-check"></i><b>2.1</b> Echantillonnage</a></li>
<li class="chapter" data-level="2.2" data-path="méthodologie.html"><a href="méthodologie.html#la-spectroscopie-à-main-et-par-drone"><i class="fa fa-check"></i><b>2.2</b> La spectroscopie à main et par drone</a></li>
<li class="chapter" data-level="2.3" data-path="méthodologie.html"><a href="méthodologie.html#la-discrimination-par-test-statistique"><i class="fa fa-check"></i><b>2.3</b> La discrimination par test statistique</a></li>
<li class="chapter" data-level="2.4" data-path="méthodologie.html"><a href="méthodologie.html#la-support-vector-machine-svm"><i class="fa fa-check"></i><b>2.4</b> La « Support Vector Machine « (SVM)</a></li>
<li class="chapter" data-level="2.5" data-path="méthodologie.html"><a href="méthodologie.html#les-forêts-aléatoires-random-forest-analysis-pour-rf"><i class="fa fa-check"></i><b>2.5</b> les Forêts Aléatoires (« Random Forest analysis » pour RF)</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="chapter" data-level="3" data-path="syntaxe.html"><a href="syntaxe.html"><i class="fa fa-check"></i><b>3</b> Syntaxe</a>
<ul>
<li class="chapter" data-level="3.1" data-path="syntaxe.html"><a href="syntaxe.html#section-in-english"><i class="fa fa-check"></i><b>3.1</b> Section in English</a></li>
<li class="chapter" data-level="3.2" data-path="syntaxe.html"><a href="syntaxe.html#documentation-pour-les-utilisateurs"><i class="fa fa-check"></i><b>3.2</b> Documentation pour les utilisateurs</a></li>
<li class="chapter" data-level="3.3" data-path="syntaxe.html"><a href="syntaxe.html#sec:docdev"><i class="fa fa-check"></i><b>3.3</b> Documentation pour les développeurs</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/Edouard-sorin/Analyse_Spectro_R.git" target="blank">Hébergé sur GitHub sur la page :</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Rapport de stage Edouard Sorin</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="méthodologie" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Méthodologie</h1>
<div id="echantillonnage" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Echantillonnage</h2>
<p>L’échantillonnage sur le terrain va tout d’abord être réalisé sur des parcelles des arbres malades et sains avec une idée du nombre d’arbres sur chaque parcelle. Le but premier va donc être de trouver les agriculteurs qui possède des parcelles avec ces caractéristiques soit avec des analyses de cartes, soit en réanalysant les données du stage de mon prédécesseur.<br />
La partie terrain va comprendre une phase d’analyse par télédétection par drone, une analyse par proxidétection à main et de prélèvement d’échantillons sur les arbres pour déterminer s’ils sont effectivement porteurs du HLB où non (via qPCR). Ces tests permettent donc de travailler sur des données vérifiées et réparties entre les mesures de spectres des arbres contaminé et des arbres sains.<br />
Le but étant de prédire le statut HLB ou non sur les arbres directement avec les spectres d’absorption, une discrimination des spectres d’absorbions est à effectuer de manière statistique. Il faut pour cela vérifier si les classes (infecté ; sain) sont séparables et de tester la performance des algorithmes (séparation significative ou non). Pour cela, deux méthodes sont envisagées, la « Support Vector Machine » (SVM) et la « Random Forest analysis » (RF).</p>
</div>
<div id="la-spectroscopie-à-main-et-par-drone" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> La spectroscopie à main et par drone</h2>
<p>Durant ce stage la détection du statut infecté en Huanglongbing (HLB) des arbres va être réalisée par deux méthodes fonctionnant sur le même principe de la spectroscopie. La première méthode est la Spectroscopie Proche Infra-Rouge (SPIR) à main qui est catégorisée comme étant de la proxi-détection. La seconde méthode est la télé-détection multispectrale par drone. <span class="citation"> (<a href="syntaxe.html#ref-albetis_de_la_cruz_potentiel_2018" role="doc-biblioref">Albetis de la Cruz, 2018</a>)</span>
Dans le cas de la télé-détection, les données sont acquises à distance de l’objet cible à l’échelle de la plante, d’un groupe ou d’une zone (figure <a href="méthodologie.html#fig:1">2.1</a>).</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:1"></span>
<img src="images/Figure2.png" alt="Photographie d’un spectromètre proche infra-rouge à main [@crequy_crequy_rapport_2020]]" width="80%" />
<p class="caption">
Figure 2.1: Photographie d’un spectromètre proche infra-rouge à main <span class="citation"> (<a href="syntaxe.html#ref-crequy_crequy_rapport_2020" role="doc-biblioref">Crequy, 2020</a>)</span>]
</p>
</div>
<p></p>
<p>Dans le cas de la proxi-détection, l’acquisition des données se fait par contact direct ou à quelques centimètres de l’objet cible à l’échelle de la feuille ou de la plante (figure <a href="méthodologie.html#fig:2">2.2</a>).</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:2"></span>
<img src="images/Figure3.png" alt="Schéma d’application des capteurs optiques (Source personnelle)" width="80%" />
<p class="caption">
Figure 2.2: Schéma d’application des capteurs optiques (Source personnelle)
</p>
</div>
<p></p>
<p>Les capteurs spectraux permettent d’analyser la réflectance des plantes dans plusieurs domaines qui sont : le visible (VIS), le proche infrarouge (PIR) et l’infrarouge courte longueur d’onde (SWIR) (figure 5). En fonction des longueurs d’onde étudiées les capteurs utilisés sont différents et regroupé en deux catégories, les capteurs multispectraux et hyperspectraux. Les capteurs multispectraux permettent d’enregistrer des bandes spectrales qui ne sont pas contiguës et qui peuvent être ciblées, par exemple : le proche infrarouge, le bleu, le rouge et le vert. A l’inverse, les capteurs hyperspectraux enregistrent plus ou moins toutes les bandes spectrales (en fonction de la résolution de l’appareil) de façon contiguë dans un intervalle de longueurs d’ondes compris entre 350 et 2500 nm. <span class="citation"> (<a href="syntaxe.html#ref-bertaux_mise_2015" role="doc-biblioref">Bertaux, 2015</a>)</span></p>
<p>Durant ce stage les deux types de capteurs vont être utilisés, le capteur hyperspectral qui sera sur la partie SPIR pour vérifier si les bandes disponibles dont des différences entre malade et sain. Et le capteur multispectral utilisé ici sur la caméra du drone est souvent utilisé dans la détection des maladies des plantes car il met en évidence un changement dans la teneur des pigments foliaires, de la structure cellulaire et de la teneur en eau des feuilles (pour ce stage 6 bandes sont disponibles et ont été choisis par les chercheurs de l’UMR télédetection).</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:3"></span>
<img src="images/Figure4.png" alt="Schéma de la variation de la réflectance de la végétation" width="80%" />
<p class="caption">
Figure 2.3: Schéma de la variation de la réflectance de la végétation
</p>
</div>
<p></p>
<p>Le but de l’utilisation de cette méthode est la discrimination des arbres sains et malades de façon rapide et clairement identifiable en passant l’outil de détection sur la parcelle. La détection de la maladie sur les plantes par télé-détection et proxi-détection repose sur la capacité des feuilles à absorber, réfléchir ou transmettre la lumière dans différentes longueurs d’onde. Ces caractéristiques sont liées à la composition biochimique des feuilles. Les variations de réflectance peuvent donc être expliquées dans les différents domaines du spectre par la teneur en pigment des feuilles dans le visible, par la structure cellulaire dans le proche infrarouge et par la teneur en eau dans le SWIR comme indiqué sur la (figure <a href="méthodologie.html#fig:3">2.3</a>). <span class="citation"> (<a href="syntaxe.html#ref-crequy_crequy_rapport_2020" role="doc-biblioref">Crequy, 2020</a>)</span>] Les bandes spectrales du visible (bleu, vert, rouge, Red-Edge) sont les plus utilisées dans la détection de maladie des feuilles. La qualité des résultats dépend de la résolution du capteur utilisé. Dans le visible (400-750nm), la coloration des feuilles est due à la teneur en chlorophylles, caroténoïdes et anthocyanes. Les chlorophylles (de type a et b) ont une absorbance dans des longueurs d’ondes correspondant au bleu et au rouge.
Les caroténoïdes ont une absorbance qui est exclusivement dans le bleu et les anthocyanes ont une absorbance qui est exclusivement dans le vert. <span class="citation"> (<a href="syntaxe.html#ref-albetis_de_la_cruz_potentiel_2018" role="doc-biblioref">Albetis de la Cruz, 2018</a>)</span>
Ensuite, dans le proche infrarouge (750-1250 nm), la réflectance n’est pas affectée par les pigments foliaires. Cette zone correspond principalement à la structure cellulaire interne des feuilles qui est aussi peu affectée en cas de maladie. Cette zone est utile pour la discrimination des feuilles entre feuillus et résineux qui ont des structures de tissus différentes. <span class="citation"> (<a href="syntaxe.html#ref-albetis_de_la_cruz_potentiel_2018" role="doc-biblioref">Albetis de la Cruz, 2018</a>)</span>
Enfin, dans le SWIR (1250-2500 nm), la réflectance est principalement dû à la teneur en eau des feuilles. Plus la réflectance est faible, plus la teneur en eau est grande, ce qui est utile pour caractériser un stress hydrique chez la plante. <span class="citation"> (<a href="syntaxe.html#ref-albetis_de_la_cruz_potentiel_2018" role="doc-biblioref">Albetis de la Cruz, 2018</a>)</span></p>
</div>
<div id="la-discrimination-par-test-statistique" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> La discrimination par test statistique</h2>
<p>Les paramètres testés lors de ces expérimentations sont l’Aire sous la courbe (AUC pour « Area Under the Curve ») et la réflectance pour une longueur donnée bien que d’autres paramètres pourront être testé suivant le déroulement des expériences réalisées.</p>
</div>
<div id="la-support-vector-machine-svm" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> La « Support Vector Machine « (SVM)</h2>
<p>La SVM est un algorithme d’apprentissage supervisé qui permet de faire des prédictions sur des variables qualitatives ou quantitatives. Un algorithme d’apprentissage supervisé se compose à la fois de données d’entrée et de données cibles. Cela permet à l’algorithme de « s’entrainer » et prédire des données de sorties plus précise ce qui va par la suite améliorer la prédiction quand il n’y aura que des données d’entrées. Dans notre étude les données d’entrée sont les spectres d’absorption échantillonnés et les données cibles sont les spectres d’absorption vérifiés par qPCR. L’objectif du SVM va consister à séparer deux classes de données, ici (infecté ; sain) pour pouvoir ensuite établir une généralisation dans la prédiction quand on ne connaitra pas la nature de l’échantillon (infecté ; sain). Pour séparer ces deux classes, l’idée est de maximiser les marges entre les échantillons et l’hyperplan séparateurs ( appelé aussi « support vector ») (figure <a href="méthodologie.html#fig:4">2.4</a>). <span class="citation"> (<a href="syntaxe.html#ref-cortes_support-vector_1995" role="doc-biblioref">Cortes et Vapnik, 1995</a>)</span></p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:4"></span>
<img src="images/Figure5.png" alt="Schéma de construction d’un hyperplan dans le cadre du SVM" width="80%" />
<p class="caption">
Figure 2.4: Schéma de construction d’un hyperplan dans le cadre du SVM
</p>
</div>
<p></p>
<p>L’apprentissage supervisé va permettre de déterminer l’équation de l’hyperplan qui séparera les jeux de données des individus sains de ceux des malades. Cela va ensuite permettre une meilleure prédiction pour les jeux de données juste échantillonnés.</p>
</div>
<div id="les-forêts-aléatoires-random-forest-analysis-pour-rf" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> les Forêts Aléatoires (« Random Forest analysis » pour RF)</h2>
<p>La RF est aussi une technique utilisant l’algorithme d’apprentissage supervisé mais cette fois-ci couplé avec un arbre de décision. Un arbre de décision est une construction de choix souvent binaire qui permet de prendre une décision. Cet algorithme permet de créer une forêt d’arbres de décision qui permet d’améliorer la généralisation (sur un paramètre recherché) de l’ensemble du modèle. La RF combine la simplicité de lecture des arbres de décision ainsi que la robustesse de l’apprentissage supervisé qui améliore la précision de la prédiction. <span class="citation"> (<a href="syntaxe.html#ref-moutarde_arbres_2017" role="doc-biblioref">Moutarde, 2017</a>)</span>
La première étape de la construction du RF est la création d’un jeu de données pour chaque arbre de décision (figure <a href="méthodologie.html#fig:5">2.5</a>). Ce jeu de données se compose des lignes des données originelles piochées aléatoirement (la même ligne pouvant être sélectionnée plusieurs fois comme la ligne 2 de l’exemple en rouge). Ce procédé augmente la variété des arbres de décision ce qui rend l’algorithme encore plus robuste. <span class="citation"> (<a href="syntaxe.html#ref-moutarde_arbres_2017" role="doc-biblioref">Moutarde, 2017</a>)</span></p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:5"></span>
<img src="images/Figure6.png" alt="Schéma 1 de construction d’un jeu de données d’un arbre de décision en RF" width="80%" />
<p class="caption">
Figure 2.5: Schéma 1 de construction d’un jeu de données d’un arbre de décision en RF
</p>
</div>
<p></p>
<p>La deuxième étape va être la création de chaque arbre de décision sur une partie différente (aléatoire et non exclusive) des données et des variables à l’intérieur de leurs jeux de données (figure <a href="méthodologie.html#fig:6">2.6</a>, rectangles de couleurs). L’intérêt est d’avoir des estimateurs différents dans chaque arbre de décision pour avoir un cheminement différent. <span class="citation"> (<a href="syntaxe.html#ref-moutarde_arbres_2017" role="doc-biblioref">Moutarde, 2017</a>)</span></p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:6"></span>
<img src="images/Figure7.png" alt="Schéma 2 de construction d’un arbre de décision en RF" width="80%" />
<p class="caption">
Figure 2.6: Schéma 2 de construction d’un arbre de décision en RF
</p>
</div>
<p></p>
<p>La troisième étape consiste à répéter l’étape 1 et 2 afin de créer autant d’arbre de décision que l’on souhaite dans le but d’obtenir un ensemble (forêt) d’arbres de décision générés aléatoirement d’où le nom de « random forest » (figure <a href="méthodologie.html#fig:7">2.7</a>). <span class="citation"> (<a href="syntaxe.html#ref-moutarde_arbres_2017" role="doc-biblioref">Moutarde, 2017</a>)</span>
Le résultat de la RF va correspondre à la moyenne des décisions de l’ensemble des arbres pour l’élément recherché.</p>
<p></p>
<div class="figure" style="text-align: center"><span id="fig:7"></span>
<img src="images/Figure8.png" alt="Schéma de construction d’une « random forest »" width="80%" />
<p class="caption">
Figure 2.7: Schéma de construction d’une « random forest »
</p>
</div>
<p></p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="problématique.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="references.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Rapport Edouard.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
